<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<title>BuddyFit State & Memory Architecture</title>
<style>
* { margin:0; padding:0; box-sizing:border-box; }
body { font-family:'Pretendard', -apple-system, 'Noto Sans KR', sans-serif;
       background:#f8f9fa; padding:30px; color:#1a1a1a; }
.page { max-width:1200px; margin:0 auto; background:#fff;
        border-radius:16px; padding:40px;
        box-shadow:0 6px 28px rgba(0,0,0,0.08); }

h1 { font-size:28px; font-weight:800; margin-bottom:8px; }
.subtitle { font-size:14px; color:#666; margin-bottom:28px; line-height:1.6; }

.section { margin-top:30px; }
.section-title { font-size:20px; font-weight:800; margin-bottom:12px;
                 border-bottom:2px solid #e5e5e5; padding-bottom:6px; }

.callout {
  background:#fafafa;
  border-left:4px solid #333;
  padding:14px 16px;
  border-radius:8px;
  font-size:13px;
  line-height:1.7;
  margin-bottom:16px;
}

.grid { display:grid;
        grid-template-columns:repeat(auto-fit,minmax(260px,1fr));
        gap:14px; font-size:13px; }

.card { border:1px solid #eee;
        border-radius:12px;
        padding:14px;
        background:#fff; }

.card h3 { font-size:15px; margin-bottom:6px; }

.table { width:100%; border-collapse:collapse; font-size:13px; margin-top:12px; }
.table th, .table td { border:1px solid #eee; padding:10px; vertical-align:top; }
.table th { background:#fafafa; text-align:left; font-size:12px; }

.highlight { background:#fff3d4; padding:2px 6px; border-radius:4px; font-weight:600; }

</style>
  <link rel="stylesheet" href="site.css" />
</head>
<body>

<nav class="nav">
  <a href="index.html">← Home</a>
</nav>

<div class="page">

<h1>BuddyFit State & Memory Architecture</h1>
<p class="subtitle">
Short Memory는 “지금 실행 가능한가?”를 판단하기 위한 상태,
Long Memory는 “이 사람은 어떤 패턴을 가지는가?”를 학습하기 위한 기억이다.
이 분리는 습관화 병목 가설을 기술적으로 강제하기 위한 설계임
</p>

<!-- 1. 설계 철학 -->
<div class="section">
<div class="section-title">1. 설계 철학: 왜 Short / Long을 분리했는가?</div>

<div class="callout">
우리의 1차 목표는 <b>습관화(지속성)</b>임.

습관화는 "지금 당장 가능한가?"의 문제이고,
루틴 최적화는 "장기 패턴은 무엇인가?"의 문제임.

이 두 문제를 동일 저장소에서 처리하면
최근 컨텍스트와 장기 패턴이 충돌하는 문제 발생.

따라서:
<ul>
<li><b>Short Memory</b> = 실행 가능성 판단용 (Session/State 중심)</li>
<li><b>Long Memory</b> = 개인화 학습용 (Vector 기반 누적 패턴)</li>
</ul>
로 역할을 명확히 분리하여 관리하도록 설계.
</div>

</div>

<!-- 2. Short Memory -->
<div class="section">
<div class="section-title">2. Short Memory (SSOT)</div>

<div class="grid">

<div class="card">
<h3>GraphState (Workflow 중심)</h3>
<ul>
<li>today_context</li>
<li>latest_mission</li>
<li>refinement_count</li>
<li>system_message</li>
<li>system_action</li>
</ul>
<p>
워크플로우 내 단일 진실 원본.
노드는 직접 파일을 수정하지 않고
State Tool을 통해서만 갱신한다.
</p>
</div>

<div class="card">
<h3>UserState</h3>
<ul>
<li>history_7d</li>
<li>miss_streak_days</li>
<li>risk_score</li>
<li>avoid_movements</li>
<li>equipment_level</li>
</ul>
<p>
습관화 판단과 안전 필터의 근거 데이터.
Downshift/Reflector/Safety Gate의 입력이 된다.
</p>
</div>

<div class="card">
<h3>TeamState</h3>
<ul>
<li>buddy_ids</li>
<li>sync_window</li>
<li>weekly_team_touch_count</li>
<li>last_nudge_at</li>
</ul>
<p>
동기부여 전략을 위한 사회적 상태.
BuddySync에서 갱신된다.
</p>
</div>

</div>

<div class="callout">
Short Memory는 JSON 기반이며,
dot-notation patch + atomic increment 방식으로 업데이트된다.
→ 상태 변경은 항상 Tool을 통해 일어나고,
직접 mutation을 막아 일관성을 유지한다.
</div>

</div>

<!-- 3. Long Memory -->
<div class="section">
<div class="section-title">3. Long Memory (Vector DB 기반)</div>

<div class="callout">
Long Memory는 "추천을 바꾸기 위한 데이터"다.
습관화 이후 단계(루틴 최적화)를 가능하게 만드는 기반.
</div>

<table class="table">
<thead>
<tr>
<th>Memory Type</th>
<th>저장 시점</th>
<th>사용 시점</th>
<th>기획 목적</th>
</tr>
</thead>
<tbody>
<tr>
<td>reflection</td>
<td>PostAction</td>
<td>Planner</td>
<td>과거 성공 경험 반영</td>
</tr>
<tr>
<td>failure_reason</td>
<td>PostAction</td>
<td>Intervention</td>
<td>끊김 원인 파악</td>
</tr>
<tr>
<td>preference</td>
<td>PostAction</td>
<td>Re-ranking</td>
<td>선호 기반 추천 강화</td>
</tr>
</tbody>
</table>

<div class="callout">
FAISS + 384d 임베딩을 사용하며,
Planner와 동일 모델을 재사용한다.
→ 검색 공간 일관성 유지.
</div>

</div>

<!-- 4. 설계 매핑 -->
<div class="section">
<div class="section-title">4. 기획 요구 ↔ Memory 매핑</div>

<table class="table">
<thead>
<tr>
<th>기획 요구</th>
<th>설계 위치</th>
<th>데이터 필드</th>
<th>왜 필요한가</th>
</tr>
</thead>
<tbody>
<tr>
<td>습관화 지속성</td>
<td>UserState</td>
<td>miss_streak_days</td>
<td>Downshift 판단 근거</td>
</tr>
<tr>
<td>부상 안전</td>
<td>UserState</td>
<td>avoid_movements</td>
<td>Safety Gate 필터링</td>
</tr>
<tr>
<td>동기부여</td>
<td>TeamState</td>
<td>weekly_team_touch_count</td>
<td>버디 활동 측정</td>
</tr>
<tr>
<td>개인화</td>
<td>Long Memory</td>
<td>reflection / preference</td>
<td>루틴 최적화 단계 진입</td>
</tr>
</tbody>
</table>

</div>

<!-- 5. 유지보수/확장 -->
<div class="section">
<div class="section-title">5. 현업 확장성</div>

<div class="callout">
이 설계는 단순 저장 구조가 아니라,
<ul>
<li>습관화 단계와 최적화 단계를 분리</li>
<li>Memory 타입 추가 확장 가능</li>
<li>Vector index 재빌드/TTL 정책 적용 가능</li>
<li>State schema 버전 관리 가능</li>
</ul>
초기 MVP에서 성장 단계까지 확장 가능한 구조를 확보하고자 함
</div>

</div>

</div>
</body>
</html>
